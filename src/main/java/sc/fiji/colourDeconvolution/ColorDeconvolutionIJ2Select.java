package sc.fiji.colourDeconvolution;

import static org.scijava.ItemIO.INPUT;
import static org.scijava.ItemIO.OUTPUT;
import static sc.fiji.colourDeconvolution.StainParameters.Constants.ALC_B_H_DESCR;
import static sc.fiji.colourDeconvolution.StainParameters.Constants.A_Z_DESCR;
import static sc.fiji.colourDeconvolution.StainParameters.Constants.CMY_DESCR;
import static sc.fiji.colourDeconvolution.StainParameters.Constants.FLG_DESCR;
import static sc.fiji.colourDeconvolution.StainParameters.Constants.FR_FB_DAB_DESCR;
import static sc.fiji.colourDeconvolution.StainParameters.Constants.GIEMSA_DESCR;
import static sc.fiji.colourDeconvolution.StainParameters.Constants.H_AEC_DESCR;
import static sc.fiji.colourDeconvolution.StainParameters.Constants.H_E2_DESCR;
import static sc.fiji.colourDeconvolution.StainParameters.Constants.H_E_DAB_DESCR;
import static sc.fiji.colourDeconvolution.StainParameters.Constants.H_E_DESCR;
import static sc.fiji.colourDeconvolution.StainParameters.Constants.H_PAS_DESCR;
import static sc.fiji.colourDeconvolution.StainParameters.Constants.MAS_TRI_DESCR;
import static sc.fiji.colourDeconvolution.StainParameters.Constants.MG_DAB_DESCR;
import static sc.fiji.colourDeconvolution.StainParameters.Constants.RGB_DESCR;
import static sc.fiji.colourDeconvolution.StainParameters.H_E;
import static sc.fiji.colourDeconvolution.StainParameters.values;

import java.util.HashMap;

import org.scijava.command.Command;
import org.scijava.command.CommandService;
import org.scijava.plugin.Parameter;
import org.scijava.plugin.Plugin;

import net.imagej.Dataset;
import net.imagej.ImgPlus;
import net.imglib2.type.numeric.integer.UnsignedByteType;

@Plugin(type = Command.class, headless = true, menuPath = "Image>Color>Color Deconvolution for ImageJ2", label = "Color Deconvolution Select",
        description = "This plugin assumes an RGB image as it's input and does a 3-color deconvolution on it with the values selected from the pulldown.")
public class ColorDeconvolutionIJ2Select implements Command {
    private static final String USER_VALUES = "User values";

    @Parameter(type = INPUT, label = " select deconvolution type",
            description = "values used for the deconvolution",
            choices = {H_E_DESCR, H_E2_DESCR, FLG_DESCR, GIEMSA_DESCR, FR_FB_DAB_DESCR, MG_DAB_DESCR, H_E_DAB_DESCR,
                    H_AEC_DESCR, A_Z_DESCR, MAS_TRI_DESCR, ALC_B_H_DESCR, H_PAS_DESCR, RGB_DESCR, CMY_DESCR, USER_VALUES},
            style = "listBox",
            initializer = "default")
    private String selection = H_E_DESCR;

    @Parameter(type = INPUT, label = "Image to color deconvolve",
            description = "The image that you would like to apply colour deconvolution on. Should be an RGB image!")
    private Dataset dataset;

    @Parameter(type = INPUT)
    private CommandService commandService;

    @Parameter(type = OUTPUT, label = "Colour 1 deconvolved Image")
    private ImgPlus<UnsignedByteType> deconvolutedImage1;
    @Parameter(type = OUTPUT, label = "Colour 2 deconvolved Image")
    private ImgPlus<UnsignedByteType> deconvolutedImage2;
    @Parameter(type = OUTPUT, label = "Remainder",
            description = "Remainder after the other 2 colours have been subtracted. Should be close to empty")
    private ImgPlus<UnsignedByteType> deconvolutedImage3;

    public ColorDeconvolutionIJ2Select() {
    }

    /**
     * This plugin is an implementation of the color deconvolution plugin from ImageJ1
     * It converts the input image (dataset) to three deconvoluted images.
     * The parameters for the deconvolution can be selected with a dropdown. For the used values see {@link StainParameters}
     *
     * From the ImageJ 1 plugin:
     * // This plugin implements stain separation using the colour deconvolution
     * // method described in:
     * //
     * //     Ruifrok AC, Johnston DA. Quantification of histochemical
     * //     staining by color deconvolution. Analytical & Quantitative
     * //     Cytology & Histology 2001; 23: 291-299.
     * //
     * // The code is based on "Color separation-30", a macro for NIH Image kindly provided
     * // by A.C. Ruifrok. Thanks Arnout!
     * //
     * // The plugin assumes images generated by color subtraction (i.e. light-absorbing dyes
     * // such as those used in bright field histology or ink on printed paper) but the dyes
     * // should not be neutral grey.
     * //
     * // I strongly suggest to read the paper reference above to understand how to determine
     * // new vectors and how the whole procedure works.
     * //
     * // The plugin works correctly when the background is neutral (white to light grey),
     * // so background subtraction and colour correction must be applied to the images before
     * // processing.
     * //
     * // The plugin provides a number of "built in" stain vectors some of which were determined
     * // experimentally in our lab (marked GL), but you may have to determine your own vectors to
     * // provide a more accurate stain separation, depending on the stains and methods you use.
     * // Ideally, vector determination should be done on slides stained with only one colour
     * // at a time (using the "From ROI" interactive option).
     * //
     * // The plugin takes an RGB image and returns three 8-bit images. If the specimen is
     * // stained with a 2 colour scheme (such as H & E) the 3rd image represents the
     * // complimentary of the first two colours (i.e. green).
     * //
     * // Please be *very* careful about how to interpret the results of colour deconvolution
     * // when analysing histological images.
     * // Most staining methods are not stochiometric and so optical density of the chromogen
     * // may not correlate well with the *quantity* of the reactants.
     * // This means that optical density of the colour may not be a good indicator of
     * // the amount of material stained.
     * //
     * // Read the paper!
     * //
     */
    @Override
    public void run() {
        if (USER_VALUES.equalsIgnoreCase(selection)) {
            commandService.run(ColorDeconvolutionIJ2FromValues.class, true, new HashMap<>());
        } else {
            StainMatrixIJ2 sm = new StainMatrixIJ2();
            StainParameters values = fromString(selection);
            sm.init("Our stain", values.rgb1()[0], values.rgb1()[1], values.rgb1()[2], values.rgb2()[0], values.rgb2()[1], values.rgb2()[2], values.rgb3()[0], values.rgb3()[1], values.rgb3()[2]);
            @SuppressWarnings("unchecked")
            ImgPlus<UnsignedByteType>[] imageStacks = sm.compute((ImgPlus<UnsignedByteType>) dataset.getImgPlus());
            deconvolutedImage1 = imageStacks[0];
            deconvolutedImage2 = imageStacks[1];
            deconvolutedImage3 = imageStacks[2];
        }
    }

    public static StainParameters fromString(String text) {
        for (StainParameters stainParameter : values()) {
            if (stainParameter.description().equalsIgnoreCase(text)) {
                return stainParameter;
            }
        }
        return H_E;
    }

    public static String getAllDescriptions() {
        StringBuilder values = new StringBuilder("{");
        for (StainParameters stainParameter : values()) {
            values.append(stainParameter.description());
            values.append(", ");
        }
        values.append("}");
        return values.toString();
    }

}
